use std::error::Error;
use std::fmt::{self, Display};
use std::io;
use std::result;
// use std::str::Utf8Error;
// use std::string::FromUtf8Error;

#[derive(Debug)]
pub enum HttpError {
    /// IO Error
    Io(io::Error),
    /// Error generated by the `http` crate.
    Http(http::Error),
    /// TLS error encountered while connecting to an https server.
    Tls(native_tls::Error),
    /// Invalid URL ecountered while processing the request or response.
    InvalidUrl(&'static str),
    /// Server sent an invalid response.
    InvalidResponse(&'static str),
    /// Decoding error happened while trying to decode text.
    DecodingError(&'static str),
}

impl Display for HttpError {
    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {
        match self {
            HttpError::Io(e) => write!(w, "Io({})", e),
            HttpError::Http(e) => write!(w, "Http({})", e),
            HttpError::Tls(e) => write!(w, "Tls({})", e),
            HttpError::InvalidUrl(s) => write!(w, "InvalidUrl({})", s),
            HttpError::InvalidResponse(s) => write!(w, "InvalidResponse({})", s),
            HttpError::DecodingError(s) => write!(w, "DecodingError({})", s),
        }
    }
}

impl Error for HttpError {
    fn description(&self) -> &str {
        match self {
            HttpError::Io(e) => e.description(),
            HttpError::Http(e) => e.description(),
            HttpError::Tls(e) => e.description(),
            HttpError::InvalidUrl(_) => "invalid URL",
            HttpError::InvalidResponse(_) => "invalid response",
            HttpError::DecodingError(_) => "decoding error",
        }
    }

    fn cause(&self) -> Option<&dyn Error> {
        match self {
            HttpError::Io(e) => Some(e),
            HttpError::Http(e) => Some(e),
            HttpError::Tls(e) => Some(e),
            _ => None,
        }
    }
}

macro_rules! impl_from {
    ($t:ty, $i:ident) => {
        impl From<$t> for HttpError {
            fn from(err: $t) -> HttpError {
                HttpError::$i(err)
            }
        }
    };
}

// impl<T> From<T> for HttpError
// where
//     T: Into<http::Error>,
// {
//     fn from(err: T) -> HttpError {
//         HttpError::Http(err.into())
//     }
// }

impl_from!(io::Error, Io);
// impl_from!(Utf8Error, Utf8);
// impl_from!(FromUtf8Error, FromUtf8);
impl_from!(http::Error, Http);
impl_from!(native_tls::Error, Tls);

pub type HttpResult<T = ()> = result::Result<T, HttpError>;
